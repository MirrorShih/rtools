import re
import os
from os import path as osp
import pandas as pd
import numpy as np
import time
import gc

import networkx as nx
# import angr
from angr import Project

import timeout_decorator
from timeout_decorator.timeout_decorator import TimeoutError

# ------ Versions ------
#  angr      |     9.2.2
#  networkx  |     2.6.3
# ----------------------

# Time out for analyzing one binary is set to 180s.
TIMEOUT = 180


def fetch_arch(df, arch='x86'):
    '''Fetch the file names with given CPU Architecture from a DataFrame object'''
    _fetch = [arch in _arch for _arch in df['CPU Architecture']]
    info = df[_fetch].sort_values(by=['filename'])
    
    return info.reset_index(drop=True)


def get_name(CFGNode_obj):
    '''Get the CFGNode name, if the node name is not defined, use address instead'''
    string = str(CFGNode_obj)

    return string.replace('>', '').split()[1]


def get_addr(CFGNode_obj):
    '''Get the CFGNode addr'''
    string = str(CFGNode_obj)

    return string.replace('>', '').split()[-1]

def function_timer(some_function):
    '''Function timer wrapper, 
    The extra time consumption will be returned as well
    e.g.
        def foo():
            xxx
            return True
        
        def foo1():
            xxx
            return True
        
        ret = foo()
        ret, time = foo1()'''

    from time import time

    def wrapper(*args, **kwargs):
        t1 = time()
        result = some_function(*args, **kwargs)
        end = time()-t1
        return result, end
    return wrapper


def buildCFG(fpath, graph_dir, logPath, save=True):
    '''The main method for building an emulated CFG,
    It calls
    1. emulate(): Get CFG from a binary emulated by angr
    2. writeLog(): Write log for each binary emulated
    3. saveCFG(): If save=True, save the CFG in the given directory, otherwise, return the CFG'''
    # file name of the binary
    fname = osp.basename(fpath)
    
    # emulate() is wrapped by function_timer(), and the return structure is ((cfg, error), time)
    (G, error), time = emulate(fpath)
    
    # write file log 
    log = [fname, error, f'{time:.0f}', str(error=='')]
    writeLog(logPath=logPath, log=log)
    
    if save and error=='':
        # empty string, e.g. '', is False in python
        G = adjustCFG(G)
        saveCFG(G=G, GName=fname, GDir=graph_dir)

    else:
        return G


@timeout_decorator.timeout(TIMEOUT)
@function_timer
def emulate(fpath):
    '''Three steps for binary emulation in angr
        1. Create a angr project
        2. Emulate CFG
        3. Save the normalized graph'''

    # Step 1:
    # If failed, return error message and skip emulating step
    p, error = createProject(fpath)
    if error:
        # Empty string, e.g. '', is False in python
        # and when the error message is not empty
        # which means there's something wrong when creating an angr Project
        return (p, error)

    # Step 2:
    # Return the (CFG, error)
    return emulateCFG(p)


def createProject(fpath):
    '''Create a angr.Project Object for a binary'''
    try:
        p = Project(fpath, load_options={'auto_load_libs': False})

        ## Notice ##
        # consider WARNING as 'information' or 'message' since it's only telling the users
        # what have been done by angr

        ## Information from a Project Object ##
        # p.arch               ## the architecture of this binary
        # p.filename           ## the file name of this binary
        # p.loader.all_objects ## all the blocks that are loaded by the loader

        # The return is structured like (project, error message)
        return (p, '')

    except Exception as e:
        error_msg = f'Project Creation Error: {e}'
        print(error_msg)
        return (None, error_msg)


def emulateCFG(proj):
    '''Emulate an angr project and generate the CFG'''
    try:
        cfg = proj.analyses.CFGEmulated(keep_state=True) # generate a emulated control flow graph
        cfg.normalize()                                    # normalize the overlapping blocks

        # The return is structured like (graph, error message)
        return (cfg.graph, '')
    
    except Exception as e:
        error_msg = f'Emulation Error: {e}'
        print(error_msg)
        return (None, error_msg)


def adjustCFG(cfg):
    '''The CFG generated by angr should be handled well before saving it, 
    or after loading the graph back, it might run into errors
    
    Error Message
        AttributeError: 'NoneType' object has no attribute 'project
        
    Guess it's due to some missing object that's defined in angr only'''

    for node in cfg.nodes(data=False):
        
        # set block name as 'bName'
        cfg.nodes[node]['bName'] = get_name(node)

        # Some node contains no disassmbly inside, or disassembly is an empty string
        # set to 'nop' instead to avoid error occurence
        if node.block is None:
            cfg.nodes[node]['x'] = [get_addr(node), 'nop']
        
        else:
            try:
                disasm = str(node.block.disassembly)
                cfg.nodes[node]['x'] = parse(node.block.disassembly) if disasm else [get_addr(node), 'nop']

            except KeyError:
                # some error that I have absolutely no clue how it happened
                cfg.nodes[node]['x'] = [get_addr(node), 'nop']

    mapping = {node: i for i, node in enumerate(cfg.nodes(data=False))}
    adjustedG = nx.relabel_nodes(cfg, mapping)
    
    return adjustedG

def logBuilder(logPath):
    '''Check whether the log is existed or not, if not, then create it'''
    if not osp.exists(logPath):
        try:
            titles = ['filename', 'error', 'time', 'complete']
            # filename | hashed filename, the same as the binary name
            # error    | error messages when applying angr to a binary
            # time     | time consumption of CFG generation
            # complete | whether the binary is parsed correctly. (True/False)

            writeLog(logPath, titles)
            print('Error Log is created')

        except OSError:
            print('Failed to create Error Log')

    else:
        print('Error Log Already Exists')


def writeLog(logPath, log):
    '''Write the log'''
    with open(logPath, 'a') as logFile:
        print(','.join(log), file=logFile)


def saveCFG(G, GName, GDir='./'):
    '''Save the graph with networkx'''
    GPath = osp.join(GDir, GName)
    GPath += '' if GPath.endswith('.gpickle') else '.gpickle'

    nx.write_gpickle(G, GPath)


def parse(disasm):
    '''Split the disassembly and address generated by angr'''
    parsed = []
    disasm = str(disasm)
    for line in disasm.split('\n'):
        addr, asm = line.split(':\t')
        asm = asm.replace('\t', ' ')
        parsed.append([addr, asm])
    return parsed



# class CFGEmulator:
    
#     def run(self, fpath, save=True):
#         ''''''
#         fname = osp.basename(fpath)
#         self.fpath = fpath          # save the file path in class object
#         self.fname = fname          # save the file name in class object
        
#         # initialize a dict object for saving binary information with 'error', 'block_info', 'time' not determined yet
#         self.binary_info = {'fname': fname, 'error': None, 'block_info': None, 'time': None}
#         start = time.time()
#         try:
#             self.apply()
#             _time = round(time.time() - start, 2)
            
#         except TimeoutError as te:
#             print(TimeOut)
#             _time = self.timeout
        
#         self.binary_info['time'] = _time
#         output = np.array(self.binary_info)
#         if save:
#             np.save(f'cfg_extracted/{fname}', output)
#         else:
#             return output
    
    
#     # @timeout_decorator.timeout(self.timeout)
#     @timeout_decorator.timeout(TIMEOUT)
#     def apply(self):
#         '''Apply three steps emulation for angr with timeout
#             Step 1: create a angr Project
#             Step 2: emulate a control flow graph
#             Step 3: disassemble each block of a CFG'''

#         # Check if 'error' exists before going on each step
#         # If error occurs in createProject() or emulateCFG() then do nothing until the end
#         if self.progress():
#             self.createProject()
            
#         if self.progress():
#             self.emulateCFG()
            
#         if self.progress():
#             self.disassembleCFG()
    
    
#     def createProject(self):
#         ''''''        
#         try:

#             # create a Project Object for a file
#             self.p = Project(self.fpath, load_options={'auto_load_libs': False})

#             ## Notice ##
#             # consider WARNING as 'information' or 'message' since it's only telling the users
#             # what have been done by angr

#             ## Information from a Project Object ##
#             # p.arch               ## the architecture of this binary
#             # p.filename           ## the file name of this binary
#             # p.loader.all_objects ## all the blocks that are loaded by the loader

#         except Exception as e:
#             error_msg = f'Project Creation Error: {e}'
#             print(error_msg)
#             self.binary_info['error'] = error_msg


#     def emulateCFG(self):
#         ''''''
#         try:
#             cfg = self.p.analyses.CFGEmulated(keep_state=True) # generate a emulated control flow graph
#             cfg.normalize()                                    # normalize the overlapping blocks
#             self.G = cfg.graph
        
#         except Exception as e:
#             error_msg = f'Emulation Error: {e}'
#             print(error_msg)
#             self.binary_info['error'] = error_msg

        
#     def disassembleCFG(self):
#         ''''''
#         block_info = {}
#         error_msg = ''
#         for i, (node, _) in enumerate(self.G.nodes(data=True)):
#             # set 'data=True' returns (node, node_attributes) pair
#             # since there's no node_attributes for now
#             # it will always return an empty list for node_attributes
#             # so it's not neccessary to set 'data=True' here
#             # but we left it for extensive use in the future
#             try:

#                 # sometimes the 'node.name' is not attainable since it might contain an address only
#                 # here we use address instead

#                 # there might be a high chance that different nodes with the same block name
#                 # since CFGEmulated() uses symbolic execution which considers the context of
#                 # the execution and thus make this kind of situation
#                 # See also: https://ble55ing.github.io/2019/06/18/angr-cfg/
#                 name = get_name(node)

#                 _block = self.p.factory.block(node.function_address) # get cfg block by the address of each block
#                 disassembly = str(_block.disassembly)                # get disassembly and convert to string

#                 # save a assembly block as np.array
#                 # format:
#                 #     [address, disassembly]
#                 block = np.array([_asm.split(': ') for _asm in disassembly.replace('\t', ' ').split('\n')])

#                 # find the successors of the current node
#                 successors = [get_name(suc) for suc in self.G.successors(node)]

#                 # save the info extracted as a list with the structure
#                 # {index: {'name': [node name], 
#                 #          'block': [address of disassembly, disassembly], 
#                 #          'successors': [successors]}}
#                 block_info[i] = {'name': name, 'block': block, 'successors': successors}

#             except Exception as e:
                
#                 error = f'Disassemble Error: {e}'
#                 print(error)
                
#                 # Not sure whether the disassemble error affect the result
#                 # so keep it unsaved
#                 error_msg += error + '\n'
                
#         self.binary_info['error'] = error_msg
#         self.binary_info['block_info'] = block_info

#     def progress(self):
#         return True if self.binary_info['error'] is None else False


if __name__=='__main__':
    dataset_dir = '/dataset/'

    dataset_info_file = osp.join(dataset_dir, 'dataset.csv')
    mal_ds_path = osp.join(dataset_dir, 'linuxmal')
    benign_ds_path = osp.join(dataset_dir, 'benignware')

    ds_info = pd.read_csv(dataset_info_file, low_memory=False)
    x86 = fetch_arch(ds_info, arch='x86')
    
    labels = x86['label']

    # if a label is not 'Benign' or 'Unknown', then it must be malware
    mal_mask = ~((labels=='BenignWare') | (labels=='Unknown'))
    mal_files = x86[mal_mask]['filename']

    benign_mask = (labels=='BenignWare')
    benign_files = x86[benign_mask]['filename']

    # get the file path of each software
    mal_fpaths = [osp.join(mal_ds_path, f[:2], f) for f in mal_files]
    benign_fpaths = [osp.join(benign_ds_path, f[:2], f) for f in benign_files]

    mal_num = len(mal_fpaths)
    benign_num = len(benign_fpaths)
    print(f'Malware numbers: {mal_num}')
    print(f'Benignware numbers: {benign_num}')

    
    for i, fpath in enumerate(mal_fpaths, start=1):

        print()
        print(f'({i}/{mal_num}) Malware {osp.basename(fpath)}')

        emulator = CFGEmulator()
        emulator.run(fpath=fpath, save=True)

        del emulator
        gc.collect()
